### 指针运算符加减举例

测试代码如下

首先定义了两个十六进制的int类型的变量，将变量b的地址赋给了p1，将b的变量中的四个字节取小地址的字节（指向99的字节）赋给了char类型的指针p2，我们前面在进行不同类型的赋值的时候是有警告的，有些编译器直接会报错，编译通不过的。这里我们进行了强制类型的转换，就告诉了编译器，这个不同类型的赋值我们作为程序员是故意而为之的，编译器就不会再对这里报错了。

![1.png](http://www.maiziedu.com/uploads/new_img/qSYK2HohMBZ3ZsypUB.png)

运行结果如下

如果我们对*p1进行输出，结果应该是99991199，但是我们对*(p1+1)和p1[1]进行输出的时候，结果却是a变量的值。我们可以想到指针变量p1的地址向后移动了一个int类型的字节数（关于两个变量在内存中的存储方向在编译原理中会讲到），就到了a变量的地址。至于*p1+1就是将p1指向的值99991199取出来再加一，显然结果也是正确的。在第一个章节的时候，我们就知道一个int类型四个字节的存储方式，它指向的是0x99（末尾不是开头），再移动一个就是存储的0x11，显然结果是正确的。

![2.png](http://www.maiziedu.com/uploads/new_img/N9LNqpSxuofrEPb6Jn.png)

通过这个例子，我们明白了指针的加减运算就是地址的偏移，指针变量的类型决定一个单位的偏移大小。C语言强大的指针访问功能可以将整个内存切割成许多的标签，你可以通过一个指针访问到整个内存，比如p[10000]，虽然这已经是越界访问了。如果我们知道某一个内存地址里面存放的是你在玩游戏时的角色的血量，你通过指针去修改这个值变为很大，那你就在游戏中无敌了。从语法角度来讲，越界是允许的，C语言不会关心你越界的问题，C的目的就是将内存标签化。但是我们作为程序员，使用指针的标签访问的时候一定要考虑它的范围大小。这也是后面我们在讲到内存分配和函数调用的时候的要介绍的，定义指针的时候我们就需要定义它的重要的属性-大小。没有大小我们就可以任意访问，任意访问就可能出现系统内存泄漏。

当我们将上面的p1[1]改成p1[10000]，编译的时候没有报错，但是运行的时候就报出了一个段错误；p1[1]改成p1[100]之后，读取了一个值，显然这个内存是可以可读取的。这就是指针越界访问的强大。