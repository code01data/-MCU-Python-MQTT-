---
categories:  #分类
    - 单片机
    - 电子模块
tags:   #标签
    - 51单片机
    - 数码管
---
# 普中51单片机学习
## 基于普中51单片机按键-数码管显示
<!-- more -->
### 硬件部分
#### 51单片机简介
51单片机是对所有兼容Intel 8031指令系统的单片机的统称。该系列单片机的始祖是Intel的8004单片机，后来随着Flash rom技术的发展，8004单片机取得了长足的进展，成为应用最广泛的8位单片机之一，其代表型号是ATMEL公司的AT89系列，它广泛应用于工业测控系统之中。很多公司都有51系列的兼容机型推出，今后很长的一段时间内将占有大量市场。51单片机是基础入门的一个单片机，还是应用最广泛的一种。需要注意的是51系列的单片机一般不具备自编程能力。
#### 独立按键

##### 基本知识

##### 1.按键分类与输入原理

1. 按键按照结构原理科分为两类，一类是触点式开关按键，如机械式开关、导电橡胶式开关灯；另一类是无触点式开关按键，如电气式按键，磁感应按键等。前者造价低，后者寿命长。目前，微机系统中最常见的是触点式开关按键。

2. 在单片机应用系统中，除了复位按键有专门的复位电路及专一的复位功能外，其他按键都是以开关状态来设置控制功能或输入数据的。当所设置的功能键或数字键按下时，计算机应用系统应完成该按键所设定的功能，键信息输入时与软件结构密切相关的过程。

3. 对于一组键或一个键盘，总有一个接口电路与CPU相连。CPU可以采用查询或中断方式了解有无将按键输入，并检查是哪一个按键按下，将该键号送人累加器，然后通过跳转指令转入执行该键的功能程序，执行完成后再返回主程序。

##### 2.按键结构与特点

微机键盘通常使用机械触点式按键开关，其主要功能式把机械上的通断转换为电气上的逻辑关系。也就是说，它能提供标准的TTL逻辑电平，以便于通用数字系统的逻辑电平相容。机械式按键再按下或释放时，由于机械弹性作用的影响，通常伴随有一定的时间触点机械抖动，然后其触点才稳定下来。其抖动过程如下图1所示，抖动时间的长短与开关的机械特性有关，一般为5-10ms。在触点抖动期间检测按键的通与断，可能导致判断出错，即按键一次按下或释放错误的被认为是多次操作，这种情况是不允许出现的。为了克服你、按键触点机械抖动所致的检测误判，必须采取消抖措施。按键较少时，可采用硬件消抖；按键较多式，采用软件消抖。

![avatar](/medias/images/mcu1.jpg)
##### 3.按键编码

一组按键或键盘都要通过I/O口线查询按键的开关状态。根据键盘结构的不同，采用不同的编码。无论有无编码，以及采用什么编码，最后都要转换成为与累加器中数值相对应的键值，以实现按键功能程序的跳转。

##### 4. 键盘程序

一个完整的键盘控制程序应具备以下功能：

1. 检测有无按键按下，并采取硬件或软件措施消抖。
 
2. 有可靠的逻辑处理办法。每次只处理一个按键，期间对任何按键的操作对系统不产生影响，且无论一次按键 时间有多长，系统仅执行一次按键功能程序。

3. 准确输出按键值（或键号），以满足跳转指令要求。

##### 独立按键

单片机控制系统中，如果只需要几个功能键，此时，可采用独立式按键结构。

1. 独立按键式直接用I/O口线构成的单个按键电路，其特点式每个按键单独占用一根I/O口线，每个按键的工作不会影响其他I/O口线的状态。独立按键的典型应用如图所示。独立式按键电路配置灵活，软件结构简单，但每个按键必须占用一个I/O口线，因此，在按键较多时，I/O口线浪费较大，不宜采用。
2. 独立按键的软件常采用查询式结构。先逐位查询没跟I/O口线的输入状态，如某一根I/O口线输入为低电平，则可确认该I/O口线所对应的按键已按下，然后，再转向该键的功能处理程序。

![avatar](/medias/images/mcu2.jpg)
##### 矩阵键盘
######  矩阵键盘的工作方式
对键盘的响应取决于键盘的工作方式，键盘的工作方式应根据实际应用系统中的CPU的工作状况而定，其选取的原则是既要保证CPU能及时响应按键操作，又不要过多占用CPU的工作时间。通常键盘的工作方式有三种，编程扫描、定时扫描和中断扫描。
#### 原理图
![avatar](/medias/images/mcu3.jpg)
![avatar](/medias/images/mcu4.jpg)
1. 编程扫描方式
编程扫描方式是利用CPU完成其它工作的空余时间，调用键盘扫描子程序来响应键盘输入的要求。在执行键功能程序时，CPU不再响应键输入要求，直到CPU重新扫描键盘为止。
2. 定时扫描方式
定时扫描方式就是每隔一段时间对键盘扫描一次，它利用单片机内部的定时器产生一定时间（例如10ms）的定时，当定时时间到就产生定时器溢出中断。CPU响应中断后对键盘进行扫描，并在有按键按下时识别出该键，再执行该键的功能程序。
3. 中断扫描方式
上述两种键盘扫描方式，无论是否按键，CPU都要定时扫描键盘，而单片机应用系统工作时，并非经常需要键盘输入，因此，CPU经常处于空扫描状态。
为提高CPU工作效率，可采用中断扫描工作方式。其工作过程如下：当无按键按下时，CPU处理自己的工作，当有按键按下时，产生中断请求，CPU转去执行键盘扫描子程序，并识别键号。
4. 矩阵键盘模块（矩阵按键显示0-F，数码管显示）

```c
#include "reg52.h"			 //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16;	  //对数据类型进行声明定义
typedef unsigned char u8;

#define GPIO_DIG P0
#define GPIO_KEY P1  //可以改变，引脚可以自定义
unsigned char  KeyValue;	//用来存放读取到的键值
unsigned char code smgduan[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//显示0~F的值//共阴数码管

/*******************************************************************************
* 函 数 名         : delay
* 函数功能		   : 延时函数，i=1时，大约延时10us
*******************************************************************************/
void delay(u16 i)
{
	while(i--);	
}
/*******************************************************************************
* 函 数 名         : KeyDown
* 函数功能		   : 检测有按键按下并读取键值
* 输    入         : 无
* 输    出         : 无
*******************************************************************************/
void KeyDown(void)
{
	unsigned char a=0;
	GPIO_KEY=0x0f;
	if(GPIO_KEY!=0x0f)//读取按键是否按下
	{
		delay(1000);//延时10ms进行消抖
		if(GPIO_KEY!=0x0f)//再次检测键盘是否按下
		{	
			//测试列
			GPIO_KEY=0X0F;
			switch(GPIO_KEY)
			{
				case(0X07):	KeyValue=0;break;
				case(0X0b):	KeyValue=1;break;
				case(0X0d): KeyValue=2;break;
				case(0X0e):	KeyValue=3;break;
			}
			//测试行
			GPIO_KEY=0XF0;
			switch(GPIO_KEY)
			{
				case(0X70):	KeyValue=KeyValue;break;
				case(0Xb0):	KeyValue=KeyValue+4;break;
				case(0Xd0): KeyValue=KeyValue+8;break;
				case(0Xe0):	KeyValue=KeyValue+12;break;
			}
			
		}
	}
	while((a<50)&&(GPIO_KEY!=0xf0))	 //检测按键松手检测
	{
		delay(100);
		a++;
	}
}
void main()
{
	 while(1)
	 {
		    KeyDown();		   //按键判断函数
			GPIO_DIG=~smgduan[KeyValue];
	 }
}
```
##### 按键代码（通过独立按键按下LED亮灭）
```c
#include"reg51.h"

/*引脚端口定义*/
sbit key1=P1^0;
sbit key2=P1^1;
sbit key3=P1^2; 
sbit key4=P1^3;

sbit led1=P2^1;
sbit led2=P2^2;

/* 声明定义*/
#define uchar unsigned char
#define uint  unsigned int
void DELAY_nMS(unsigned int time);	
void key_scan(void);

/*函数主体部分*/
void DELAY_nMS(unsigned int time)//DELAY_nMS(1)//延迟一毫秒
{
  unsigned int  i,j;             
  for(i=0;i<time;i++)    
     for(j=0;j<939;j++); 
}	
/*独立按键扫描函数*/
void key_scan(void)
{
	if(key1==0)		  //检测按键K1是否按下
	{	
		DELAY_nMS(10);   //消除抖动 一般大约10ms
		if(key1==0)	 //再次判断按键是否按下
		{
			led1=~led1;	  //led状态取反
		}
		while(!key1);	 //检测按键是否松开
	}	
	if(key2==0)		  //检测按键K1是否按下
	{	
		DELAY_nMS(10);   //消除抖动 一般大约10ms
		if(key2==0)	 //再次判断按键是否按下
		{
			led2=~led2;	  //led状态取反
		}
		while(!key2);	 //检测按键是否松开
	}	

}

void keyscan(void)
{
  if(key1==0)		  //检测按键K1是否按下
	{	
		DELAY_nMS(10);   //消除抖动 一般大约10ms
		if(key1==0)	 //再次判断按键是否按下
		{
				          //执行需要完成的操作
		}
		while(!key1);	 //检测按键是否松开
	}	
}


/*主函数部分*/
void main(void)
{
	while(1)
	{
		key_scan();
	}
}


```
#### 数码管
数码管，也称作辉光管，是一种可以显示数字和其他信息的电子设备。玻璃管中包括一个金属丝网制成的阳极和多个阴极。大部分数码管阴极的形状为数字。管中充以低压气体，通常大部分为氖加上一些汞和/或氩。给某一个阴极充电，数码管就会发出颜色光，视乎管内的气体而定，一般都是橙色或绿色。
数码管
共阳数码管
共阳数码管在应用时应将公共极COM接到+5V，当某一字段发光二极管的阴极为低电平时，相应字段就点亮，当某一字段的阴极为高电平时，相应字段就不亮。
共阴数码管
对于共阴极数码管来说，当某个发光二极管的阳极为高电平时，发光二极管点亮，相应的段被显示。同样，共阳极数码管的阳极连接在一起，公共阳极接+5V，当某个发光二极管的阴极接低电平时，该发光二极管被点亮，相应的段被显示。
![avatar](/medias/images/mcu8.jpg)
静态数码管硬件电路设计
![avatar](/medias/images/mcu9.jpg)

```c
unsigned char code LED_0F[] ={0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 
0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e};//共阳数码管
unsigned char code  smgduan[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};////共阴数码管
``` 
```c
#include "reg52.h"			 //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16;	  //对数据类型进行声明定义
typedef unsigned char u8;


unsigned char code table[]={0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 
0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e};

void delay(unsigned int i)
{
	unsigned int m,n;
	for(m=i;m>0;m--)
		for(n=90;n>0;n--);
}
/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{	

	unsigned char num;
	while(1)

	{ 
			for (num = 0; num < 17; ++num)
			{
				P0=table[num];
				delay(500);
				//P0=0x00;
			}
  }
		
}
```
#### 138译码器
###### 74HC138 芯片
74HC138D 是一种三通道输入、 八通道输出译码器， 主要应用于消费类电子产品。
1. 主要特性
采用 CMOS 工艺
低功耗
工作电压： 3.0V-5.0V
封装形式： SOP16
2. 原理图
![avatar](/medias/images/mcu5.jpg)
3. 引脚功能定义
![avatar](/medias/images/mcu6.jpg)
4. 真值表
![avatar](/medias/images/mcu7.jpg)
5. 工作原理
从上面的管脚功能定义说明及真值表可以知道该芯片使用方法非常简单， 给E1、 E2 使能管脚低电平， E3 管脚为高电平， 至于哪个管脚输出有效电平（低电平） ， 要看 A0， A1， A2 输入管脚的电平状态。 如果 A0， A1， A2 都为低电平， 则Y0 输出有效电平（低电平） ， 其他管脚均输出高电平。 如果 A0 为高电平， A1，A2 都为低电平， 则 Y1 输出有效电平（低电平） ， 其他管脚均输出高电平。 其他几种输出大家可以对照真值表查看。 如果 E1、 E2 使能管脚任意一个为高电平或
者 E3 为低电平， 不论输入是什么， 输出都为高电平。

6. 总结
A0、 A1、 A2 输入就相当于 3 位 2 进制数， A0 是低位， A1 是次高位， A2 是高位。 而 Y0-Y7 具体哪一个输出有效电平， 就看输入二进制对应的十进制数值。 
例如：
  输入是 101（A2， A1， A0） ， 其对应的十进制数是 5， 所以 Y5 输出有效电平（低电平）。

## 软件代码(按键数码管显示)
```c
#include "reg52.h"	//此文件中定义了单片机的一些特殊功能寄存器
typedef unsigned int u16;	 //对数据类型进行声明定义
typedef unsigned char u8;
/*端口引脚定义*/
sbit LSA=P2^2;
sbit LSB=P2^3;
sbit LSC=P2^4;
sbit KEY1 = P3^0;
sbit KEY2 = P3^1;
/*变量定义*/
int number;
unsigned char KeyNum=0;   //被触发的按键编号
unsigned char KeyLock1=0;
unsigned char KeyLock2=0;
unsigned int cnt;

/*函数声明部分*/
void KEY_Scan();
void KEY_Action();
void Light_Scan();
void delay(u16 i);
void Display();
void Time0Iint();
/*数码管码表*/
unsigned char code smgduan[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,
					0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};//共阴数码管显示0~F的值
unsigned char LightBuf[]={0xFF,0xFF,0xFF,0xFF,0XFF};
/*******************************************************************************
* 函 数 名         : delay
* 函数功能		   : 延时函数，i=1时，大约延时10us
*******************************************************************************/
void delay(u16 i)
{
	while(i--);	
}
/*******************************************************************************
* 函 数 名         : Display
* 函数功能		   : 数码管显示部分
*******************************************************************************/
void Display()
{
		LightBuf[0]=smgduan[number%10];
		LightBuf[1]=smgduan[number/10%10];
		LightBuf[2]=smgduan[number/100%10];
		LightBuf[3]=smgduan[number/1000%10];
	    LightBuf[4]=smgduan[number/10000%10];
	
}
/*******************************************************************************
* 函 数 名         : Light_Scan()
* 函数功能		   : 数码管扫描函数，选择显示的位置
*******************************************************************************/
void Light_Scan()
{
	u8 i;
	for(i=0;i<8;i++)
	{
		switch(i)	 //位选，选择点亮的数码管，
		{
			case(0):
				LSA=0;LSB=0;LSC=0;P0=LightBuf[4];break;//显示第0位
			case(1):
				LSA=1;LSB=0;LSC=0;P0=LightBuf[3];break;//显示第1位
			case(2):
				LSA=0;LSB=1;LSC=0;P0=LightBuf[2];break;//显示第2位
			case(3):
				LSA=1;LSB=1;LSC=0;P0=LightBuf[1];break;//显示第3位
			case(4):
				LSA=0;LSB=0;LSC=1;P0=LightBuf[0];break;//显示第4位
			default: break;
		}
		delay(100); //间隔一段时间扫描	
		P0=0x00;//消隐
	}
}
/*******************************************************************************
* 函 数 名         : KEY_Scan()
* 函数功能		   : 按键扫描函数
*******************************************************************************/
void KEY_Scan()
{
	static unsigned char cnt1 = 0xFF;
	static unsigned char cnt2 = 0xFF;
  cnt1 =(cnt1<<1)|KEY1;
	cnt2 =(cnt2<<1)|KEY2;
	if(cnt1 != 0x00)
	{
		  KeyLock1 = 0;
	}
	else if(KeyLock1==0)
	{
	  	KeyNum = 1;
		  KeyLock1 = 1;
	}
	if(cnt2 != 0x00)
	{
		 KeyLock2 = 0;
	}
	else if(KeyLock2==0)
	{
	  	 KeyNum = 2;
		  KeyLock2 = 1;
	}
}
/*******************************************************************************
* 函 数 名         :  KEY_Action()
* 函数功能		   : 按键执行操作部分
*******************************************************************************/
void KEY_Action()
{
	 switch(KeyNum)
	 {
	        case 1:number++; KeyNum = 0; break;
	        case 2:number--; KeyNum = 0; break;
	   	    default:break;          
	  }
}
/*******************************************************************************
* 函 数 名         :Time0Iint

* 函数功能		   :定时器0配置，定时器初始化函数
*******************************************************************************/
void Time0Iint()
{
		EA=1;
		TH0 = (65536-2000)/256;//定时2ms
		TL0 = (65536-2000)%256;
		TMOD &= 0xFC;
		TMOD =  0x01;
		ET0 = 1;
		TR0 = 1;
}
/*******************************************************************************
* 函 数 名         :void InterruptT0() interrupt 1
* 函数功能		   : 定时器0中断执行部分
*******************************************************************************/
void InterruptT0() interrupt 1
{
		TH0 = (65536-2000)/256;//定时2ms
		TL0 = (65536-2000)%256;
		Light_Scan();
		KEY_Scan();
}
/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{	 
	Time0Iint();
	while(1)
	{	
		Display();
		KEY_Action();
	}		
}
``` 
